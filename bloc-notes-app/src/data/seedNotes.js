// Généré par scripts/seed-from-resources.js - ne pas éditer à la main
export const seedNotes = [
  { id: "seed-projet-block-notes", title: "Projet block notes", content: "# Crée ton bloc-notes (1/2)\n\nDans le projet d'aujourd'hui, tu vas recréer l'application **Bloc-Notes** disponible sur tous les appareils. Tu pourras même y accéder en hors-ligne et toujours avoir tes données stockées. Tu utiliseras des **composants fonctionnels** et les **hooks** React (voir la ressource *Composants-fonctionnels*).\n\n## 1. Introduction\n\nL'une des applications les plus connues au monde est le simple bloc-notes. Disponible sur Windows comme sur Mac, ce dernier peut servir à n'importe quel moment, et pour tout le monde.\n\nTon objectif, aujourd'hui, sera de créer un bloc-notes. Dans celui-ci, tu pourras écrire en markdown, et ton texte sera affiché en live sous forme de HTML.\n\nSi tu ne sais pas comment écrire en markdown, c'est facile, ne t'en fais pas : suis ce lien.\n\nL'ensemble des notes sera stocké côté navigateur (localStorage ou IndexedDB). Ainsi, tu ne risques aucun souci avec le RGPD.\n\n## 2. L'application\n\nTon application sera constituée de plusieurs parties.\n\n- **À gauche** : une barre de navigation avec la liste des notes. L'utilisateur y voit un titre et le début du texte (~15 mots). Un bouton en haut permet de créer une nouvelle note.\n- **À droite** (~80 % de la largeur) : en haut, le contenu de la note sélectionnée, rendu en HTML ; en bas, un champ pour le titre de la note et un textarea pour le contenu en markdown.\n\nPour transformer le markdown en HTML, tu utiliseras une lib adaptée à React (par ex. **react-markdown**) : le markdown s'affiche en live en haut. La sauvegarde se fait au clic sur un bouton « Save » (ou en option : sauvegarde automatique toutes les X secondes). Les notes sont persistées (localStorage ou IndexedDB) pour rester visibles après rechargement. L'utilisateur peut changer de note en cliquant dans la liste à gauche et modifier chaque note à sa guise.\n\n## 3. Rendu attendu\n\nLe rendu attendu est un repo GitHub contenant ton application.\n\n- L'utilisateur peut ajouter une note.\n- L'utilisateur peut modifier une note.\n- L'utilisateur peut consulter une note.\n- L'utilisateur peut basculer entre les notes pour voir celle qu'il veut.\n- *[Optionnel]* Le bouton « Sauvegarder » n'existe plus : les notes sont sauvegardées automatiquement (par ex. toutes les 2 secondes après la dernière frappe).\n\n## 4. La démarche à suivre\n\nCe projet peut sembler compliqué, j'ai donc décidé de t'assister un peu et de te guider jusqu'à ce que tu aies créé une note. Tu seras ensuite en autonomie pour la gestion de plusieurs notes. Ne te mets pas la pression : tu peux valider l'épreuve si tu arrives à faire une seule note correctement sauvegardée.\n\nPour commencer, initialise une application React (par ex. avec **Vite** : `npm create vite@latest bloc-notes-app --template react`).\n\nTon composant `App` contiendra au moins deux parties pour la zone de droite : **NoteDisplay** (affichage du markdown rendu) et **MarkdownInput** (saisie du titre et du contenu markdown + bouton de sauvegarde). Tout sera écrit en **composants fonctionnels** avec des hooks (voir la ressource *Composants-fonctionnels*).\n\n### 4.1. MarkdownInput\n\nCommence par le **MarkdownInput**. Deux étapes :\n\n1. **Composant contrôlé** : le textarea est piloté par un state (ex. `useState` pour le contenu). Chaque frappe met à jour ce state.\n2. **Callback vers le parent** : le parent (ex. `App`) peut recevoir la valeur du textarea via une fonction passée en prop (ex. `onContentChange`). Dans un premier temps, cette fonction peut faire un `console.log` de la valeur.\n\nPour le composant contrôlé, tu peux t'appuyer sur la doc React ou sur la ressource *Composants-fonctionnels* (state avec `useState`). Pour le callback parent, la doc React sur les props et la remontée d’état s’applique pareil en composants fonctionnels.\n\n### 4.2. NoteDisplay\n\nLe parent (`App`) récupère la donnée du textarea (via le state ou le callback), puis la passe à **NoteDisplay** en prop (ex. `content` ou `markdown`).\n\nDans NoteDisplay, tu affiches ce markdown converti en HTML. Avec **react-markdown**, tu n'as pas besoin de `dangerouslySetInnerHTML` : le composant gère le rendu de façon sûre. Exemple :\n\n```bash\nnpm install react-markdown remark-gfm\n```\n\n```tsx\nimport ReactMarkdown from 'react-markdown'\nimport remarkGfm from 'remark-gfm'\n\nfunction NoteDisplay({ markdown }: { markdown: string }) {\n  return (\n    <div className=\"prose\">\n      <ReactMarkdown remarkPlugins={[remarkGfm]}>{markdown}</ReactMarkdown>\n    </div>\n  )\n}\n```\n\nÀ chaque fois que tu écris dans l'éditeur, tu devrais voir le rendu se mettre à jour en live au-dessus.\n\n### 4.3. Sauvegarder les données\n\nAjoute un bouton « Save » dans **MarkdownInput**. Au clic, une fonction `handleSave` enregistre les données (titre + contenu markdown) dans le **localStorage** (ex. `localStorage.setItem('blocNote', ...)`). Vérifie avec `console.log(localStorage.getItem('blocNote'))` que les données sont bien enregistrées.\n\nAu chargement de l'app, récupère ces données pour initialiser le state. Pour éviter d’appeler `localStorage.getItem()` à chaque rendu, utilise une **fonction d’initialisation** dans `useState` : `useState(() => JSON.parse(localStorage.getItem('blocNote') ?? 'null'))` (ou une structure adaptée à tes notes).\n\n*Pour aller plus loin* : tu peux remplacer le localStorage par **IndexedDB** (par ex. avec `idb-keyval`) pour gérer plus de notes et plus de données — voir la *recommandation* du projet.\n\n### 4.4. À toi de jouer\n\nAvec tout ça, à toi de concevoir la liste de notes à gauche, la sélection de la note courante, et la gestion de plusieurs notes. Souviens-toi qu’il n’y a pas de trop petit composant.\n", createdAt: 1770246831875, updatedAt: 1770246831875 },
  { id: "seed-projet-bonus-formulaire", title: "Projet Bonus Formulaire", content: "# Projet bonus : Mettre en place un formulaire\n\nDans ce projet, tu mettras en place un formulaire pour créer un compte pour un programme d'apprentissage au développement, en utilisant des composants UI modernes (**Shadcn UI** — voir la ressource *Shadcn-UI*).\n\nCe projet n'est pas validant : ne le fais pas en priorité, tu peux le reprendre en fin de semaine. Il sert à utiliser Shadcn UI (ou une lib de composants) et à te familiariser avec React en composants fonctionnels.\n\n## 1. Présentation\n\nPour t'exercer à utiliser une lib de composants, tu vas mettre en place un formulaire fonctionnel. Les créateurs de THP souhaitent changer le formulaire de contact pour renseigner toutes les informations d'inscription à un programme d'apprentissage au développement. Tu mettras ce formulaire en place pour les aider.\n\nTu utiliseras **Shadcn UI** pour les champs, boutons, sélecteurs, etc. (voir la ressource *Shadcn-UI*). Lorsque le formulaire sera envoyé, s'il n'y a pas d'erreur, l'utilisateur verra une notification de confirmation.\n\n## 2. L'application\n\nTon application demandera plusieurs données. À toi de choisir le composant le plus adapté pour chaque type de champ (Input, Select, RadioGroup, etc.) et de les mettre en required ou non.\n\nLes champs seront organisés en **trois étapes**.\n\n**Contact :**\n- Nom  \n- Prénom  \n- Genre  \n- Date de naissance  \n- Mail  \n- Téléphone  \n- Ville  \n\n**Développement :**\n- Niveau en développement web (général)  \n- Langages connus et niveau pour chacun  \n- Langage que l'utilisateur souhaite apprendre (liste)  \n\n**Prise de rendez-vous (optionnel) :**\n- Motif (liste)  \n- Date souhaitée  \n\nPour passer à l'étape suivante, tous les champs de l'étape en cours doivent être valides ; sinon, l'utilisateur voit des messages d'erreur.\n\nQuand toutes les étapes sont remplies et validées, l'utilisateur voit une notification indiquant qu'il sera contacté. Les informations peuvent être affichées dans la console sous forme d'un objet.\n\n## 3. Pour aller plus loin\n\nQuand tu auras fini, tu peux par exemple :\n\n- Enchaîner avec **React Hook Form** et **Zod** pour la validation et la gestion des erreurs (voir la *recommandation* du projet).\n- Reste en **composants fonctionnels** et hooks ; c’est le standard actuel (voir la ressource *Composants-fonctionnels*).\n\n---\n\n*Projet principal : [Crée ton bloc-notes (1/2)](./Projet%20block%20notes.md)*\n", createdAt: 1770246831875, updatedAt: 1770246831875 },
  { id: "seed-shadcn-ui", title: "Shadcn-UI", content: "# Shadcn UI\n\nParfois, nous n'avons pas besoin de tout designer from scratch dans nos applications React. Des bibliothèques de composants nous permettent d'avancer vite tout en gardant la main sur le code. **Shadcn UI** est une collection de composants réutilisables que tu copies dans ton projet (tu en deviens propriétaire) et que tu styles avec **Tailwind CSS**.\n\n## 1. Introduction\n\nShadcn UI n'est pas une dépendance npm classique : ce sont des composants **copiés dans ton repo** (souvent dans `src/components/ui/`). Tu les installes via une CLI qui ajoute uniquement le code dont tu as besoin. Basés sur **Radix UI** (accessibilité, comportements) et **Tailwind CSS** (styles), ils sont entièrement personnalisables car le code vit chez toi. Idéal pour des apps React modernes (Vite, React 18/19, JavaScript).\n\n## 2. Historique et contexte\n\nShadcn UI est maintenu activement et s'aligne sur l'écosystème actuel : React 19, Tailwind CSS 4, JavaScript. Pas de bundle CSS global à importer : tout est en utilitaires Tailwind et variables CSS. Les composants ciblent les navigateurs modernes (plus de support IE11). Si tu veux une UI cohérente, accessible et facile à thématiser (ex. dark mode), Shadcn est un choix solide en 2025–2026.\n\n## 3. La ressource\n\n### 3.1. Prérequis et installation\n\nTu dois avoir un projet **Vite + React** (JavaScript) avec **Tailwind CSS** déjà configuré. Ensuite, initialiser Shadcn une seule fois à la racine du projet :\n\n```bash\nnpx shadcn@latest init\n```\n\nRéponds aux questions (style : Default, base color : Slate, CSS variables : Yes, etc.). La CLI crée notamment :\n\n- `components.json` (config des chemins)\n- `src/lib/utils.js` avec la fonction `cn()` pour fusionner les classes Tailwind\n\nEnsuite, installe uniquement les composants dont tu as besoin, par exemple Button et un sélecteur :\n\n```bash\nnpx shadcn@latest add button\nnpx shadcn@latest add select\n```\n\nChaque composant est ajouté dans `src/components/ui/` (ou le chemin que tu as choisi). Aucun `import '.../global.css'` type Ant Design : le style vient de Tailwind et du thème défini dans ton CSS.\n\n### 3.2. Utilisation\n\nAprès l'installation, les composants sont dans ton code. Exemple avec un **Select** (équivalent conceptuel au Cascader pour un cas simple) et un **Button** :\n\n```tsx\nimport { Button } from '@/components/ui/button'\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select'\n\nfunction App() {\n  return (\n    <div className=\"p-6 flex flex-col gap-4\">\n      <p>Composants Shadcn UI + Tailwind</p>\n\n      <Select>\n        <SelectTrigger className=\"w-[280px]\">\n          <SelectValue placeholder=\"Choisis une option\" />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"thp\">THP</SelectItem>\n          <SelectItem value=\"react\">React</SelectItem>\n          <SelectItem value=\"rails\">Rails</SelectItem>\n        </SelectContent>\n      </Select>\n\n      <Button>Clique moi</Button>\n      <Button variant=\"outline\">Outline</Button>\n    </div>\n  )\n}\n```\n\nPour découvrir tous les composants disponibles (Input, Dialog, Card, etc.), consulte la doc officielle et utilise la CLI pour les ajouter au projet au fur et à mesure.\n\n### 3.3. Icons : Lucide React\n\nPour les icônes, la stack moderne recommande **Lucide React** : cohérent avec Shadcn, léger, tree-shakeable.\n\nInstallation :\n\n```bash\nnpm install lucide-react\n```\n\nUtilisation : importe l’icône dont tu as besoin et utilise-la comme composant. Tu peux lui passer des props (taille, couleur) via `className` ou `style` :\n\n```tsx\nimport { Plus, Trash2, Twitter } from 'lucide-react'\n\nfunction MyComponent() {\n  return (\n    <div className=\"flex gap-2 items-center\">\n      <Plus className=\"h-5 w-5 text-primary\" />\n      <Trash2 size={20} className=\"text-destructive\" />\n      <Twitter style={{ fontSize: '24px', color: '#08c' }} />\n    </div>\n  )\n}\n```\n\nPas de package séparé à configurer : une seule dépendance `lucide-react`, et tu n’importes que les icônes utilisées.\n\n## 4. Ce qu'il faut retenir\n\n- Shadcn UI = composants **copiés dans ton repo**, pas une grosse lib à importer. Tu gardes le contrôle du code et du style.\n- Stack typique pour ce projet : Vite + React + JavaScript + Tailwind CSS + Shadcn (Radix + Tailwind) + Lucide pour les icônes (JavaScript uniquement).\n- Pas d’import CSS global dédié : tout passe par Tailwind et ton thème (variables CSS, dark mode, etc.).\n- Pour un nouveau projet React moderne, Shadcn UI + Lucide est une alternative solide et à jour aux anciennes libs (Ant Design, Material UI) dans beaucoup de cas.\n\n## 5. Pour aller plus loin\n\n- Documentation officielle : [ui.shadcn.com](https://ui.shadcn.com)\n- Composants disponibles : parcourir le site et ajouter au besoin avec `npx shadcn@latest add <component>`.\n- Lucide : [lucide.dev](https://lucide.dev) pour chercher les icônes et copier le nom du composant à importer depuis `lucide-react`.\n\nSi tu veux comparer avec d’autres approches, tu peux regarder **Radix UI** (primitives sans style) ou **Material UI** (MUI) ; Shadcn apporte une couche Radix + Tailwind prête à l’emploi et facile à adapter.\n", createdAt: 1770246831875, updatedAt: 1770246831875 },
  { id: "seed-composants-fonctionnels", title: "Composants-fonctionnels", content: "# Les composants fonctionnels (Function Components)\n\nAujourd’hui, la façon recommandée d’écrire des composants React est d’utiliser des **fonctions** plutôt que des classes. On parle de **Function Components**. Avec les **hooks** (depuis React 16.8), tu gères le state et le cycle de vie directement dans ces fonctions, sans `this` ni constructeur.\n\n## 1. Introduction\n\nUn composant fonctionnel est une fonction JavaScript qui reçoit des **props** en argument et retourne du **JSX**. Pour le state et les effets de bord (appels API, timers, abonnements), tu utilises des **hooks** fournis par React : `useState`, `useEffect`, `useRef`, etc. C’est le modèle standard pour tout nouveau code React en 2025–2026.\n\n## 2. Historique et contexte\n\nAvant React 16.8, le state et le cycle de vie n’étaient disponibles que dans les **Class Components**. Les Function Components servaient surtout à des composants “simples” sans state. Depuis l’arrivée des hooks, les Function Components permettent de tout faire (state, lifecycle, contexte) avec un code plus court et plus lisible, sans `this` ni `bind`. React recommande désormais les Function Components pour les nouveaux projets ; les Class Components restent utiles pour **lire** d’anciens projets ou pour une migration progressive.\n\n## 3. La ressource\n\n### 3.1. Mettre en place un Function Component\n\nOn part d’un composant minimal : un titre et un paragraphe. Avec un projet Vite + React, le point d’entrée utilise `createRoot` (React 18+) :\n\n```tsx\nimport { createRoot } from 'react-dom/client'\nimport App from './App'\n\nconst root = document.getElementById('root')\nif (root) {\n  createRoot(root).render(<App />)\n}\n```\n\nLe composant `App` est une simple fonction qui retourne du JSX :\n\n```tsx\nfunction App() {\n  return (\n    <div>\n      <h1>Hello world</h1>\n      <p>How are you?</p>\n    </div>\n  )\n}\n\nexport default App\n```\n\nTu peux aussi écrire en fléchée : `const App = () => { ... }`. Pas de classe, pas de `render()`, pas de `this` : la fonction *est* le composant.\n\n### 3.2. Les props\n\nLes props sont le premier argument de la fonction. Tu les déstructure souvent pour plus de clarté :\n\n```jsx\nfunction HelloName({ name }) {\n  return <h2>Hello {name}!</h2>\n}\n\nexport default HelloName\n```\n\nLe parent passe les props comme d’habitude : `<HelloName name=\"Alice\" />`. En JavaScript, les props sont des objets ; tu peux les déstructurer directement dans les paramètres.\n\n### 3.3. Le state : useState\n\nPour un state local, tu utilises le hook **useState**. Il renvoie la valeur actuelle et une fonction pour la mettre à jour. Exemple compteur :\n\n```tsx\nimport { useState } from 'react'\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n\n  const increment = () => setCount(count + 1)\n  const decrement = () => setCount(count - 1)\n\n  return (\n    <div>\n      <button type=\"button\" onClick={increment}>+</button>\n      <button type=\"button\" onClick={decrement}>-</button>\n      <p>Compteur : {count}</p>\n    </div>\n  )\n}\n\nexport default Counter\n```\n\nContrairement aux Class Components, tu peux avoir autant de `useState` que nécessaire, chacun pour une donnée précise. Pour des mises à jour basées sur la valeur précédente (éviter les race conditions), passe une fonction à `setCount` :\n\n```tsx\nsetCount((prev) => prev + 1)\n```\n\nPlusieurs valeurs de state : plusieurs hooks :\n\n```tsx\nfunction MyComponent() {\n  const [count, setCount] = useState(0)\n  const [name, setName] = useState('Jean')\n  const [items, setItems] = useState([])\n\n  const increment = () => {\n    setCount((prev) => prev + 1)\n  }\n\n  return (\n    <div>\n      <p>{name}, compteur : {count}</p>\n      {/* ... */}\n    </div>\n  )\n}\n```\n\nPas d’objet `this.state` unique : chaque state est isolé et plus facile à raisonner.\n\n### 3.4. Pas de constructeur : initialisation et refs\n\nEn Function Component, il n’y a pas de constructeur. Le code en haut du corps de la fonction s’exécute à chaque rendu. Pour une valeur qui ne doit pas déclencher de re-render (référence à un élément DOM, identifiant de timer, etc.), tu utilises **useRef** :\n\n```tsx\nimport { useRef } from 'react'\n\nfunction MyComponent() {\n  const inputRef = useRef(null)\n  const intervalIdRef = useRef(null)\n\n  const focusInput = () => {\n    inputRef.current?.focus()\n  }\n\n  return <input ref={inputRef} type=\"text\" />\n}\n```\n\nPour l’initialisation du state à partir d’une opération coûteuse (ex. lecture du `localStorage`), tu peux passer une **fonction** à `useState` : elle ne sera exécutée qu’au premier rendu :\n\n```tsx\nconst [data, setData] = useState(() => {\n  return JSON.parse(localStorage.getItem('key') ?? '[]')\n})\n```\n\n### 3.5. Le cycle de vie : useEffect\n\nLe hook **useEffect** remplace les méthodes de cycle de vie des classes (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) en un seul endroit. La fonction que tu passes est exécutée après le rendu ; le tableau de dépendances indique *quand* la ré-exécuter, et la fonction de cleanup (optionnelle) correspond au démontage.\n\n**Après le montage uniquement** (équivalent de `componentDidMount`) :\n\n```tsx\nimport { useState, useEffect } from 'react'\n\nfunction UsersPage() {\n  const [data, setData] = useState<unknown[]>([])\n\n  useEffect(() => {\n    fetch('https://my-api.com/acme')\n      .then((res) => res.json())\n      .then((data) => setData(data))\n  }, []) // tableau vide = une seule fois au montage\n\n  return (\n    <div className=\"UsersPage\">\n      {data.length > 0 ? <UsersList data={data} /> : <Loading />}\n    </div>\n  )\n}\n```\n\n**Réagir à un changement de prop** (équivalent de `componentDidUpdate` ciblé) :\n\n```tsx\nfunction UserPage({ userId }) {\n  const [userData, setUserData] = useState(null)\n\n  useEffect(() => {\n    fetchUser(userId).then(setUserData)\n  }, [userId]) // re-exécuté quand userId change\n\n  return (\n    <div className=\"UserPage\">\n      {userData && <UserProfile data={userData} />}\n    </div>\n  )\n}\n```\n\n**Cleanup au démontage** (équivalent de `componentWillUnmount`) :\n\n```tsx\nfunction MyComponent() {\n  const intervalIdRef = useRef(null)\n\n  useEffect(() => {\n    intervalIdRef.current = setInterval(() => {\n      fetchNotifications()\n    }, 5000)\n\n    return () => {\n      if (intervalIdRef.current) clearInterval(intervalIdRef.current)\n    }\n  }, [])\n\n  return <div>...</div>\n}\n```\n\nLa fonction retournée par `useEffect` est appelée au démontage du composant (et avant de ré-exécuter l’effet si les dépendances changent). C’est là qu’on nettoie les timers, abonnements, etc., pour éviter les fuites mémoire.\n\nRésumé rapide :\n\n- **Montage** : `useEffect(fn, [])`\n- **Mise à jour** (quand une valeur change) : `useEffect(fn, [propOuState])`\n- **Démontage / cleanup** : `return () => { ... }` dans le `useEffect`\n\n## 4. Ce qu’il faut retenir\n\n- Les **Function Components** sont des fonctions qui prennent des props et retournent du JSX. C’est la forme recommandée pour tout nouveau code React.\n- Le **state** se gère avec **useState** (une ou plusieurs valeurs), sans `this.state` ni `this.setState`.\n- Les **props** sont le premier argument de la fonction (objet JavaScript).\n- Il n’y a **pas de constructeur** : initialisation via `useState(() => ...)` si besoin, et **useRef** pour références ou valeurs qui ne déclenchent pas de rendu.\n- Le **cycle de vie** se gère avec **useEffect** : tableau de dépendances pour “quand” exécuter, fonction de retour pour le cleanup (démontage).\n\nConnaître les Class Components reste utile pour lire d’anciens projets ; pour écrire du nouveau code, privilégie toujours les Function Components et les hooks.\n\n## 5. Pour aller plus loin\n\n- Documentation React (hooks) : [react.dev/reference/react](https://react.dev/reference/react)\n- Règles des hooks : ne les appeler qu’en haut du composant (pas dans des conditions ou boucles).\n- Autres hooks utiles : `useContext`, `useMemo`, `useCallback`, `useReducer` pour des cas plus avancés.\n\nSi tu tombes sur du code avec des Class Components, tu peux le migrer progressivement vers des Function Components en remplaçant `this.state` / `setState` par `useState`, et les méthodes de lifecycle par `useEffect`.\n", createdAt: 1770246831875, updatedAt: 1770246831875 },
  { id: "seed-recommandation", title: "recommandation", content: "INSTRUCTIONS CURSOR - PROJET BLOC-NOTES PRO 2026\nStack : Vite + React 19 + JavaScript + Tailwind CSS 4 + Shadcn UI + IndexedDB\n\n> **Alignement avec le sujet** : Cette recommandation implémente le projet *Crée ton bloc-notes (1/2)* (voir `Resources/Projet block notes.md`) en version « pro » : mêmes fonctionnalités (sidebar, liste notes, preview markdown, éditeur, persistance) + auto-save, IndexedDB, Zustand, validation. Noms de composants : *NoteDisplay* (sujet) = *NotePreview* (ici) ; *MarkdownInput* (sujet) = partie éditeur dans *NoteEditor*.\n\nPHASE 1 : SETUP INITIAL (Copy-paste dans terminal Cursor)\nbash\n# Création projet Vite React (JavaScript)\nnpm create vite@latest bloc-notes-app --template react\ncd bloc-notes-app\n\n# Installation dépendances base\nnpm install\n\n# Installation Tailwind CSS 4 (plugin Vite, pas PostCSS)\nnpm install -D tailwindcss @tailwindcss/vite\n\n# Installation Shadcn UI dependencies\nnpm install class-variance-authority clsx tailwind-merge lucide-react\n\n# Installation state management & data\nnpm install zustand idb-keyval\n\n# Installation markdown processing (remplacement Showdown obsolète)\nnpm install react-markdown remark-gfm rehype-raw rehype-sanitize\n\n# Installation React Hook Form + Zod\nnpm install react-hook-form @hookform/resolvers zod\n\n# Installation dev tools\nnpm install -D @biomejs/biome\n\n# Init Biome (remplace ESLint+Prettier)\nnpx @biomejs/biome init\n\n# Init Git\ngit init && git add -A && git commit -m \"chore: init vite react js stack 2026\"\nPHASE 2 : CONFIGURATION TAILWIND CSS 4\nUtiliser le plugin Vite (pas PostCSS) pour éviter les erreurs de compatibilité. Remplacer contenu src/index.css :\n\ncss\n@import \"tailwindcss\";\n\n@layer base {\n  body {\n    @apply antialiased;\n    font-feature-settings: \"rlig\" 1, \"calt\" 1;\n  }\n}\nPHASE 3 : CONFIGURATION BIOME\nRemplacer contenu biome.json :\n\njson\n{\n  \"$schema\": \"https://biomejs.dev/schemas/1.9.4/schema.json\",\n  \"vcs\": {\n    \"enabled\": true,\n    \"clientKind\": \"git\",\n    \"useIgnoreFile\": true\n  },\n  \"files\": {\n    \"ignoreUnknown\": false,\n    \"ignore\": [\"node_modules\", \"dist\", \"build\"]\n  },\n  \"formatter\": {\n    \"enabled\": true,\n    \"indentStyle\": \"space\",\n    \"indentWidth\": 2,\n    \"lineWidth\": 100\n  },\n  \"organizeImports\": {\n    \"enabled\": true\n  },\n  \"linter\": {\n    \"enabled\": true,\n    \"rules\": {\n      \"recommended\": true\n    }\n  },\n  \"javascript\": {\n    \"formatter\": {\n      \"quoteStyle\": \"single\",\n      \"semicolons\": \"asNeeded\"\n    }\n  }\n}\nPHASE 4 : CONFIGURATION VITE (alias @/ + Tailwind)\nMettre à jour vite.config.js à la racine :\n\njavascript\nimport path from 'node:path'\nimport react from '@vitejs/plugin-react'\nimport tailwindcss from '@tailwindcss/vite'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [react(), tailwindcss()],\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n})\nPHASE 5 : STRUCTURE DES DOSSIERS\nCréer l'arborescence suivante dans src/ :\n\nbash\nsrc/\n├── components/\n│   ├── ui/           # Composants Shadcn UI\n│   ├── NoteEditor.jsx\n│   ├── NotePreview.jsx\n│   ├── NoteSidebar.jsx\n│   └── NoteItem.jsx\n├── lib/\n│   ├── utils.js      # Helpers Tailwind (cn function)\n│   └── db.js         # IndexedDB wrapper\n├── stores/\n│   └── notesStore.js # Zustand store\n├── App.jsx\n├── main.jsx\n└── index.css\nPHASE 6 : CODE SOURCE COMPLET (À GÉNÉRER PAR CURSOR)\nInstruction pour Cursor (prompt unique) :\ntext\nGénère le code production-ready suivant pour une app Bloc-notes React moderne :\n\nSPECS FONCTIONNELLES :\n- Sidebar gauche avec liste des notes (titre + preview 15 mots)\n- Zone principale avec prévisualisation markdown en haut + éditeur en bas\n- Éditeur markdown avec input titre + textarea contenu\n- Sauvegarde auto toutes les 2 secondes (debounce) dans IndexedDB\n- Bouton \"Nouvelle note\" en haut du sidebar\n- Clic sur note dans sidebar = chargement dans éditeur\n- Preview markdown live avec react-markdown (support GFM + tables)\n- UI moderne Tailwind CSS 4 avec dark mode par défaut\n\nARCHITECTURE :\n1. Modèle de note (objet JS) :\n   - Note : { id, title, content, createdAt, updatedAt } (id string, dates en number)\n\n2. IndexedDB wrapper (/src/lib/db.js) :\n   - Fonctions : getAllNotes(), getNote(id), saveNote(note), deleteNote(id)\n   - Utiliser idb-keyval avec store 'notes'\n   - Chaque note = clé unique UUID\n\n3. Zustand store (/src/stores/notesStore.js) :\n   - State : notes[], currentNoteId, isLoading\n   - Actions : loadNotes(), selectNote(id), createNote(), updateNote(note), deleteNote(id)\n   - Synchronisation avec IndexedDB automatique\n\n4. Composants :\n   \n   A. NoteSidebar (/src/components/NoteSidebar.jsx) :\n      - Liste scrollable des notes\n      - Bouton \"Nouvelle note\" avec icon Lucide Plus\n      - NoteItem pour chaque note (affiche titre + 15 premiers mots content)\n      - Active state si note sélectionnée\n      - Tailwind : bg-slate-900, w-80, border-r, hover effects\n\n   B. NoteEditor (/src/components/NoteEditor.jsx) :\n      - Input controlled pour titre (className: text-2xl font-bold)\n      - Textarea controlled pour markdown (className: font-mono, min-h-[300px])\n      - useEffect avec debounce 2s pour auto-save via store.updateNote()\n      - React Hook Form + Zod validation (titre requis, max 100 chars)\n\n   C. NotePreview (/src/components/NotePreview.jsx) :\n      - ReactMarkdown avec plugins remark-gfm, rehype-raw, rehype-sanitize\n      - Styles prose Tailwind : className=\"prose prose-invert max-w-none\"\n      - Affiche le markdown rendu en HTML live\n\n   D. Layout principal (App.jsx) :\n      - Flex layout : NoteSidebar (fixe) + split vertical NotePreview/NoteEditor\n      - Split 50/50 avec résizer optionnel (ou simple border)\n      - useEffect initial pour loadNotes()\n      - Dark mode par défaut (bg-slate-950, text-slate-100)\n\n5. Utils (/src/lib/utils.js) :\n   - Fonction cn() pour merge classNames (clsx + tailwind-merge)\n   - Fonction generateId() pour UUID v4\n   - Fonction truncateText(text, words) pour preview\n\n6. Main.jsx :\n   - Pas de StrictMode en dev (double render)\n   - Import index.css\n\nSTANDARDS CODE 2026 :\n- Functional components only, hooks React 19\n- JavaScript uniquement\n- Zustand selectors pour éviter re-renders\n- Arrow functions, const/let, template literals\n- Comments uniquement pour logique complexe\n- Error handling avec try/catch sur IndexedDB ops\n- Loading states pendant fetch notes\n- Empty states avec messages clairs\n\nSTYLING TAILWIND :\n- Design system cohérent : slate color palette\n- Dark mode par défaut (no toggle pour simplifier)\n- Spacing consistent : p-4, gap-4, etc.\n- Border radius : rounded-lg\n- Shadows : shadow-md pour cartes\n- Transitions : transition-colors duration-200\n- Responsive pas nécessaire (desktop first)\n\nPERFORMANCE :\n- Lazy loading react-markdown si >10 notes\n- Debounce auto-save 2s (lodash.debounce ou custom hook)\n- Zustand selectors : const title = useNotesStore(s => s.notes.find(n => n.id === currentId)?.title)\n- React.memo sur NoteItem si liste >50 notes\n\nEDGE CASES :\n- Première visite : créer note par défaut \"Bienvenue\"\n- Suppression note courante : sélectionner première note restante\n- Sidebar vide : message \"Aucune note, créez-en une !\"\n- Erreur IndexedDB : fallback state in-memory + toast warning\n\nOUTPUT ATTENDU :\n- Génère tous les fichiers avec code complet ready-to-run\n- Inclure imports corrects (paths alias @/)\n- Aucun TODO, aucun placeholder\n- Code production-grade, pas de console.log\n- Code JavaScript propre et lisible\n\nBONUS (si temps) :\n- Bouton delete note (icon Trash Lucide) dans NoteItem\n- Confirmation dialog avant delete (dialog Shadcn UI)\n- Raccourcis clavier : Cmd+N nouvelle note, Cmd+S save manuelle\nPHASE 7 : SHADCN UI COMPONENTS (Optionnel si besoin dialog/button)\nInstaller composants Shadcn manuellement (si pas de CLI setup) :\n\nbash\n# Setup Shadcn CLI\nnpx shadcn@latest init\n\n# Répondre prompts :\n# - Style: Default, Base color: Slate, etc.\n# - Style: Default\n# - Base color: Slate\n# - CSS variables: Yes\n# - Tailwind : géré par le plugin @tailwindcss/vite (pas de postcss.config.js)\n# - Components path: @/components\n# - Utils path: @/lib/utils\n\n# Installer composants utiles\nnpx shadcn@latest add button\nnpx shadcn@latest add dialog\nnpx shadcn@latest add input\nnpx shadcn@latest add textarea\nnpx shadcn@latest add toast\nPHASE 8 : SCRIPTS PACKAGE.JSON\nAjouter dans package.json :\n\njson\n{\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\",\n    \"lint\": \"biome check --write ./src\",\n    \"format\": \"biome format --write ./src\"\n  }\n}\nPHASE 9 : LANCEMENT & TEST\nbash\n# Lancer dev server\nnpm run dev\n\n# Ouvrir http://localhost:5173\n\n# Tester workflow :\n# 1. App lance, charge notes depuis IndexedDB (vide première fois)\n# 2. Créer nouvelle note via bouton sidebar\n# 3. Taper titre + markdown dans éditeur\n# 4. Vérifier preview live en haut\n# 5. Attendre 2s auto-save (ou Cmd+S)\n# 6. Recharger page, note persiste\n# 7. Créer 2-3 notes supplémentaires\n# 8. Switcher entre notes via sidebar\n# 9. Tester delete note si implémenté\n\n# Vérifier IndexedDB dans DevTools :\n# Application > Storage > IndexedDB > notes > keyval\nPHASE 10 : AMÉLIORATIONS POST-MVP\nSi projet terminé en avance, ajouter :\n\nSearch notes : Input en haut sidebar, filter par titre/contenu\n\nTags system : Array tags dans l’objet note, badges Tailwind\n\nExport notes : Bouton download en .md ou .json\n\nRich markdown toolbar : Boutons bold, italic, link (insert syntax)\n\nNote templates : Dropdown \"New from template\" (Meeting, Todo, etc.)\n\nSync cloud : Upload notes vers Supabase/Firebase (optionnel)\n\nKeyboard shortcuts : useHotkeys hook pour Cmd+K search, Cmd+Delete, etc.\n\nCHECKLIST QUALITÉ FINALE\n Aucune erreur Biome (npm run lint)\n\n Toutes notes persistent après refresh\n\n Auto-save fonctionne (attendre 2s sans typer)\n\n Preview markdown affiche correctement : headers, lists, code blocks, tables\n\n Sidebar scrollable si >10 notes\n\n UI cohérente Tailwind (spacing, colors, fonts)\n\n Loading state initial visible\n\n Empty state si aucune note\n\n Performance fluide (pas de lag typing)\n\n Code commenté uniquement si logique non-évidente\n\n Imports organisés (Biome auto-sort)\n\n Aucun console.log en production\n\n Build production OK (npm run build) sans warnings\n\nTECH STACK FINAL\ntext\nFrontend:\n  - React 19 (Functional components + Hooks)\n  - JavaScript uniquement\n  - Vite 6 (dev server instantané)\n  - Tailwind CSS 4 (PostCSS, no config file)\n\nUI:\n  - Shadcn UI (components ownership)\n  - Lucide React (icons modernes)\n  - Dark mode par défaut\n\nState:\n  - Zustand (client state 2KB)\n  - IndexedDB via idb-keyval (persistence)\n\nMarkdown:\n  - react-markdown (rendering)\n  - remark-gfm (GitHub Flavored Markdown)\n  - rehype-raw + rehype-sanitize (sécurité HTML)\n\nForms:\n  - React Hook Form (performance)\n  - Zod (validation type-safe)\n\nQuality:\n  - Biome (linter + formatter 20x faster)\n  - Git hooks optionnel (Husky + lint-staged)\nRESOURCES COMPLÉMENTAIRES\nVite docs : https://vitejs.dev\n\nTailwind CSS 4 : https://tailwindcss.com/docs\n\nShadcn UI : https://ui.shadcn.com\n\nZustand : https://docs.pmnd.rs/zustand\n\nidb-keyval : https://github.com/jakearchibald/idb-keyval\n\nreact-markdown : https://github.com/remarkjs/react-markdown\n\nBiome : https://biomejs.dev", createdAt: 1770246831875, updatedAt: 1770246831875 },
]